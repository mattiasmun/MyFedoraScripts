#!/usr/bin/python
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import subprocess
import time
import json
from pynput import keyboard, mouse

class AutoClickerGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Merged Auto-Clicker GUI")
        self.geometry("650x700")
        self.resizable(False, False)

        # Event to signal the clicking loop to stop
        self.stop_event = threading.Event()
        self.is_running = False
        self.thread = None
        self.listener = None

        # Get screen dimensions once when the app starts
        try:
            output = subprocess.run(['xrandr'], capture_output=True, text=True, check=True)
            for line in output.stdout.splitlines():
                if '*' in line:
                    resolution = line.split()[0]
                    self.screen_width, self.screen_height = map(int, resolution.split('x'))
                    break
            else:
                self.screen_width, self.screen_height = 1920, 1080
                messagebox.showwarning("Warning", "Could not determine screen resolution. Using default 1920x1080.")
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            self.screen_width, self.screen_height = 1920, 1080
            messagebox.showerror("Error", f"Could not run xrandr to get screen dimensions: {e}. Using default 1920x1080.")

        # New thread for cursor position tracking
        self.cursor_pos_thread = None
        self.stop_cursor_thread = threading.Event()

        # File for persistent settings
        self.SETTINGS_FILE = "settings.json"

        # Style configuration for a modern look
        self.style = ttk.Style(self)
        self.style.theme_use('clam')
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TLabel', background='#f0f0f0', font=('Arial', 10))
        self.style.configure('TButton', font=('Arial', 10, 'bold'))
        self.style.configure('TCheckbutton', background='#f0f0f0')
        self.style.configure('TEntry', fieldbackground='white')
        self.style.configure('Heading.TLabel', font=('Arial', 16, 'bold'))

        # Create the main frame
        self.main_frame = ttk.Frame(self, padding=20)
        self.main_frame.pack(fill=tk.BOTH, expand=True)

        # Title
        self.title_label = ttk.Label(self.main_frame, text="Dotool GUI Clicker", style='Heading.TLabel')
        self.title_label.pack(pady=(0, 20))

        # Cursor Position Label
        self.cursor_pos_label = ttk.Label(self.main_frame, text="Cursor Position: (0, 0)", font=('Arial', 12, 'bold'))
        self.cursor_pos_label.pack(pady=5)

        # Coordinates Input
        self.coords_frame = ttk.Frame(self.main_frame)
        self.coords_frame.pack(fill=tk.X, pady=5)
        ttk.Label(self.coords_frame, text="X Coordinate:").pack(side=tk.LEFT, padx=(0, 5))
        self.x_entry = ttk.Entry(self.coords_frame, width=10)
        self.x_entry.pack(side=tk.LEFT, padx=(0, 10))
        ttk.Label(self.coords_frame, text="Y Coordinate:").pack(side=tk.LEFT, padx=(0, 5))
        self.y_entry = ttk.Entry(self.coords_frame, width=10)
        self.y_entry.pack(side=tk.LEFT)

        # Duration Input
        self.duration_frame = ttk.Frame(self.main_frame)
        self.duration_frame.pack(fill=tk.X, pady=5)
        ttk.Label(self.duration_frame, text="Duration (seconds) (0 for infinite):").pack(side=tk.LEFT, padx=(0, 5))
        self.duration_entry = ttk.Entry(self.duration_frame, width=10)
        self.duration_entry.pack(side=tk.LEFT)

        # Delay Input
        self.delay_frame = ttk.Frame(self.main_frame)
        self.delay_frame.pack(fill=tk.X, pady=5)
        ttk.Label(self.delay_frame, text="Delay between clicks (seconds):").pack(side=tk.LEFT, padx=(0, 5))
        self.delay_entry = ttk.Entry(self.delay_frame, width=10)
        self.delay_entry.pack(side=tk.LEFT)

        # Alt+Tab Checkbox
        self.alt_tab_var = tk.BooleanVar()
        self.alt_tab_check = ttk.Checkbutton(self.main_frame, text="Switch Window (Alt+Tab)", variable=self.alt_tab_var)
        self.alt_tab_check.pack(pady=10)

        # Control Buttons
        self.button_frame = ttk.Frame(self.main_frame)
        self.button_frame.pack(pady=20)
        self.start_button = ttk.Button(self.button_frame, text="Start", command=self.start_clicking)
        self.start_button.pack(side=tk.LEFT, padx=10)
        self.stop_button = ttk.Button(self.button_frame, text="Stop", command=self.stop_clicking, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=10)

        # Status Label
        self.status_label = ttk.Label(self.main_frame, text="Status: Ready", font=('Arial', 10, 'italic'))
        self.status_label.pack(pady=10)

        # Instructions Section
        self.instructions_label = ttk.Label(self.main_frame,
            text="Instructions:\n"
                 "1. Move your mouse to the desired position. The coordinates will update automatically.\n"
                 "2. Enter the X and Y coordinates to click.\n"
                 "3. Optionally, check the 'Switch Window' box to use Alt+Tab.\n"
                 "4. Press 'Start' to begin the clicking process.\n"
                 "5. **Press the ESC key on your keyboard to stop the process at any time.**",
            justify=tk.LEFT)
        self.instructions_label.pack(pady=10, fill=tk.X)

        # Start the keyboard listener thread
        self.listener = keyboard.Listener(on_press=self.on_press)
        self.listener.start()

        # Load and set the initial settings
        self.load_settings()

        # Start the cursor position update thread
        self.cursor_pos_thread = threading.Thread(target=self.update_cursor_position)
        self.cursor_pos_thread.daemon = True
        self.cursor_pos_thread.start()

        # Bind the closing event to the on_closing method
        self.protocol("WM_DELETE_WINDOW", self.on_closing)

    def send_dotool_command(self, command):
        """
        Sends a command to dotoolc by writing to its standard input.
        This is a more reliable method than using a shell pipe.
        """
        try:
            subprocess.run(
                ["dotoolc"],
                input=command.encode('utf-8'),
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError as e:
            print(f"Error executing dotoolc command '{command}':")
            print(e.stderr.decode('utf-8'))
        except FileNotFoundError:
            messagebox.showerror("Error", "dotoolc command not found. Please ensure 'dotool' is installed and in your PATH.")

    def dotool_click(self, x, y):
        """
        Performs a click at the specified pixel coordinates.
        Converts pixel coordinates to a percentage for the 'mouseto' command.
        """
        x_pct = x / self.screen_width
        y_pct = y / self.screen_height

        # Now move to the target coordinates and click
        self.send_dotool_command(f"mouseto {x_pct} {y_pct}")
        time.sleep(0.1)
        self.send_dotool_command("click left")

    def alt_tab_with_dotool(self):
        """Performs a more reliable Alt+Tab key sequence using dotool."""
        self.send_dotool_command("keydelay 100")
        self.send_dotool_command("keyhold 100")
        self.send_dotool_command("key alt+k:15")
        # A short delay is still good practice to give the system time to react
        time.sleep(0.5)

    def on_closing(self):
        """Handles the window closing event."""
        # Save settings before closing
        self.save_settings()

        # Stop all threads
        self.stop_clicking()
        self.stop_cursor_thread.set()

        # Close the Tkinter window
        self.destroy()

    def on_press(self, key):
        """Pynput callback to stop the clicking loop on ESC key press."""
        try:
            if key == keyboard.Key.esc:
                print("Escape key pressed. Stopping script…")
                self.stop_clicking()
                return False  # Stops the listener
        except AttributeError:
            pass

    def update_cursor_position(self):
        """Continuously updates the cursor position label."""
        while not self.stop_cursor_thread.is_set():
            try:
                x, y = mouse.Controller().position
                # Use self.after to update the GUI from a background thread
                self.after(50, lambda: self.cursor_pos_label.config(text=f"Cursor Position: ({x}, {y})"))
                time.sleep(0.1)
            except Exception as e:
                print(f"Error updating cursor position: {e}")
                break

    def save_settings(self):
        """Saves the current settings to a JSON file."""
        settings = {
            "x": self.x_entry.get(),
            "y": self.y_entry.get(),
            "duration": self.duration_entry.get(),
            "delay": self.delay_entry.get(),
            "alt_tab": self.alt_tab_var.get()
        }
        try:
            with open(self.SETTINGS_FILE, 'w') as f:
                json.dump(settings, f)
        except Exception as e:
            print(f"Error saving settings: {e}")

    def load_settings(self):
        """Loads settings from a JSON file. If the file is not found, it inserts default values."""
        try:
            with open(self.SETTINGS_FILE, 'r') as f:
                settings = json.load(f)
                self.x_entry.insert(0, settings.get("x", ""))
                self.y_entry.insert(0, settings.get("y", ""))
                self.duration_entry.insert(0, settings.get("duration", ""))
                self.delay_entry.insert(0, settings.get("delay", ""))
                self.alt_tab_var.set(settings.get("alt_tab", False))
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Settings file not found or invalid: {e}. Using default values.")
            self.duration_entry.insert(0, "10")
            self.delay_entry.insert(0, "0.05")

    def start_clicking(self):
        if self.is_running:
            return

        try:
            x = int(self.x_entry.get())
            y = int(self.y_entry.get())
            duration = float(self.duration_entry.get())
            delay = float(self.delay_entry.get())

            if delay <= 0:
                messagebox.showerror("Invalid Input", "Delay must be a positive number.")
                return
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter valid numbers.")
            return

        self.is_running = True
        self.stop_event.clear()
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.status_label.config(text="Status: Running…")

        self.thread = threading.Thread(target=self.clicking_loop, args=(x, y, duration, delay))
        self.thread.daemon = True
        self.thread.start()

    def stop_clicking(self):
        if not self.is_running:
            return

        self.is_running = False
        self.stop_event.set()
        self.status_label.config(text="Status: Stopping…")

        # No longer need to self-join; the thread will naturally exit after the loop.

        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.status_label.config(text="Status: Stopped")

    def clicking_loop(self, x, y, duration, delay):
        if self.alt_tab_var.get():
            try:
                self.alt_tab_with_dotool()
            except Exception as e:
                print(f"Error switching windows: {e}")

        # Dummy move to (0,0) once before the loop to ensure 'mouseto' works
        self.send_dotool_command("mouseto 0 0")

        start_time = time.time()
        while not self.stop_event.is_set() and (duration == 0 or time.time() - start_time < duration):
            try:
                self.dotool_click(x, y)
                time.sleep(delay)
            except Exception as e:
                print(f"Error during clicking: {e}")
                self.stop_event.set()

        self.stop_clicking()

if __name__ == "__main__":
    app = AutoClickerGUI()
    app.mainloop()


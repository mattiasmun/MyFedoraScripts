#!/usr/bin/bash

# Kontrollera om en söksträng angavs
if [ -z "$1" ]; then
    echo "Användning: $0 <söksträng>"
    echo "Exempel: $0 logg (matchar 'logg', 'LOGG', 'Logg', etc. i filnamnet/sökvägen)"
    echo "         $0 .conf (matchar '.conf', '.CONF', '.Conf', etc. i filnamnet/sökvägen)"
    exit 1
fi

SEARCH_STRING_LOWER=$(echo "$1" | tr '[:upper:]' '[:lower:]') # Konvertera söksträngen till små bokstäver
START_PATH="." # Sök alltid från aktuell katalog

echo "Söker efter filer vars SÖKVÄG/FILNAMN innehåller '$1' (skiftlägesokänsligt), från '$START_PATH'…"

# Skapa en temporär fil för att lagra de hittade filnamnen
temp_file=$(mktemp)

# Sök efter filer, filtrera och spara resultatet som null-avgränsade strängar i den temporära filen.
# Detta är den mest robusta metoden för att hantera filnamn med mellanslag.
find "$START_PATH" -type f -print0 | \
    while IFS= read -r -d $'\0' filename; do
        filename_lower=$(echo "$filename" | tr '[:upper:]' '[:lower:]')
        if [[ "$filename_lower" == *"$SEARCH_STRING_LOWER"* ]]; then
            printf "%s\0" "$filename" # Skicka null-avgränsade filnamn vidare
        fi
    done > "$temp_file" # Omdirigera hela pipen till den temporära filen

# Kontrollera om den temporära filen är tom (storlek noll)
if [ ! -s "$temp_file" ]; then
    echo "----------------------------------------------------"
    echo "Inga filer hittades som matchar söksträngen."
    rm "$temp_file"
    exit 0
fi

echo "Sorterar efter storlek i fallande ordning:"
echo "----------------------------------------------------"

# Använd de funna filerna från den temporära filen för att fortsätta pipelinen
# 'cat' skickar innehållet till xargs som nu korrekt tolkar null-avgränsningarna.
cat "$temp_file" | \
    xargs -0 du -b | \
    sort -nr | \
    while read -r size_bytes filename; do
        # Kör ls på det faktiska filnamnet för att få utdatan
        ls -ldh --time-style=+%Y-%m-%d\ %H:%M:%S "$filename" | \
            awk '{
                # ls -l utdata: permissions, links, owner, group, size, month, day, time, filename
                # $5 = size (human readable)
                # $6, $7, $8 = date/time (formatted)
                
                # För att få korrekt filnamn som kan hantera mellanslag:
                file_start_col = 9;
                for (i = file_start_col; i <= NF; i++) {
                    if (i == file_start_col) { filename_part = $i; }
                    else { filename_part = filename_part " " $i; }
                }
                print $5, $6, $7, $8, filename_part
            }'
    done

# Rensa upp den temporära filen när programmet är klart
rm "$temp_file"

